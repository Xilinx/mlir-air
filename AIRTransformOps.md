<!-- Autogenerated by mlir-tblgen; don't manually edit -->

### `transform.air.copy_to_dma` (transform::CopyToDmaOp)

Syntax:

```
operation ::= `transform.air.copy_to_dma` $target attr-dict
```

Transform a `memref.copy` operation into a `air.dma_memcpy_nd` operation.
Returns the new `air.dma_memcpy_nd` operation.

Traits: `FunctionalStyleTransformOpTrait`, `TransformEachOpTrait`

Interfaces: `MemoryEffectsOpInterface`, `TransformOpInterface`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `target` | PDL handle to an `mlir::Operation *` |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | PDL handle to an `mlir::Operation *` |


### `transform.air.fuse_into_containing_op` (transform::FuseIntoContainingMemrefOp)

_Fuse a producer into a containing operation._

Syntax:

```
operation ::= `transform.air.fuse_into_containing_op` $producer_op `into` $containing_op attr-dict
```

Fuses the `producer_op` into the `containing_op`.
Returns a handle to the fused ops.

The producer is a subview slice of a tiled op. This transform computes the
accessed producer slice inside of the containing op ("tile and fuse").

The containing op handle must be associated with exactly one payload op. The
producer op handle may be associated with multiple payload ops. This
transform fuses exactly one producer.

#### Return modes

If the producer could not be fused, this operation fails silently.
This is the case when tiling fails or when the producer op has zero uses
within the containing op. I.e., "producers" that are not consumed within the containing
op are rejected by this operation.

This operation reads and frees the producer handle.
This operation reads the containing op handle.

Interfaces: `MemoryEffectOpInterface`, `TransformOpInterface`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `producer_op` | PDL handle to an `mlir::Operation *` |
| `containing_op` | PDL handle to an `mlir::Operation *` |

#### Results:

| Result | Description |
| :----: | ----------- |
| `fused_op` | PDL handle to an `mlir::Operation *` |


### `transform.air.get_segment_for` (transform::GetSegmentForOp)

_Gets a handle to the parent 'air.segment' of the given operation_

Syntax:

```
operation ::= `transform.air.get_segment_for` $target attr-dict
```

Produces a handle to the parent `air.segment` op for each payload IR
operation associated with the operand. Fails if a segment cannot be found.
The list of operations associated with the handle contains
parent operations in the same order as the list associated with the operand,
except for operations that are parents to more than one input which are only
present once.

Traits: `NavigationTransformOpTrait`

Interfaces: `MemoryEffectsOpInterface`, `TransformOpInterface`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `target` | PDL handle to an `mlir::Operation *` |

#### Results:

| Result | Description |
| :----: | ----------- |
| `parent` | PDL handle to an `mlir::Operation *` |


### `transform.air.linalg_promote` (transform::LinalgPromoteOp)

Syntax:

```
operation ::= `transform.air.linalg_promote` $target attr-dict
```

Promotes the specified operands of the target into a separate memory buffer
using the `mlir::linalg::promoteSubViews` utility.

This operation applies to Linalg ops that satisfy the
`mlir::linalg::promoteSubviewsPrecondition`, otherwise it fails.

When successful, several optimization passes are run on the resulting IR.
The return handle points to the `target` operation that was modified
inplace.

The operation accepts as attributes the fields in
`mlir::linalg::LinalgPromotionOptions`. In addition the memory space in
allocated buffers can be specified with with the memory_space attribute as
"L1", "L2" or "L3". The default memory space is L1.

example:
```mlir
%0 = transform.structured.match ops{["linalg.matmul"]} in %code  : (!pdl.operation) -> !pdl.operation
%1 = transform.air.linalg_promote %0 {memory_space="L2", operands_to_promote=[0]}
```

The `group_size` attribute is used to apply promotion to multiple
linalg ops. When `group_size=N`, the `operands_to_promote` attribute refers to
`N` payload operations at a time and the operand indices apply to the
operands of the `N` operations in the order they appear in the target handle.

For example,
```mlir
%m = transform.structured.match ops{["linalg.matmul"]} in %f : (!pdl.operation) -> !pdl.operation
%f = transform.structured.match ops{["linalg.fill"]} in %f : (!pdl.operation) -> !pdl.operation
%h = transform.merge_handles %f, %m : !pdl.operation
// promote the input of the fill operation and the output of the matmul operation to L1 memory
transform.air.linalg_promote %h {"group_size"=2, "operands_to_promote"=[1,4], "memory_space"="L1"}
```

Interfaces: `MemoryEffectOpInterface`, `TransformOpInterface`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>operands_to_promote</code></td><td>::mlir::ArrayAttr</td><td>64-bit integer array attribute</td></tr>
<tr><td><code>group_size</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr>
<tr><td><code>use_full_tile_buffers</code></td><td>::mlir::ArrayAttr</td><td>1-bit boolean array attribute</td></tr>
<tr><td><code>use_full_tiles_by_default</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr>
<tr><td><code>use_alloca</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr>
<tr><td><code>alignment</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr>
<tr><td><code>memory_space</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `target` | PDL handle to an `mlir::Operation *` |

#### Results:

| Result | Description |
| :----: | ----------- |
| `transformed` | PDL handle to an `mlir::Operation *` |


### `transform.air.linalg_tile` (transform::LinalgTileOp)

Tile a linalg operation with the given sizes. Optionally apply an
interchange of the resulting loops. The new linalg operantion and all
generated loops are returned. Tiling is performed with the
`linalg::LinalgTilingLoopType::ParallelLoops` so that `scf.parallel`
loops are generated whenever possible.

This is a variant of `transform.structured.tile`.

Interfaces: `MemoryEffectOpInterface`, `TransformOpInterface`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>static_sizes</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute</td></tr>
<tr><td><code>interchange</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `target` | PDL handle to an `mlir::Operation *` |
| `dynamic_sizes` | variadic of PDL handle to an `mlir::Operation *` |

#### Results:

| Result | Description |
| :----: | ----------- |
| `tiled_linalg_op` | PDL handle to an `mlir::Operation *` |
| `loops` | variadic of PDL handle to an `mlir::Operation *` |


### `transform.air.par_to_herd` (transform::ParToHerdOp)

Syntax:

```
operation ::= `transform.air.par_to_herd` $target attr-dict
```

Transform a `scf.parallel` operation into a `air.herd` operation.
If the `scf.parallel` operation has more than two dimensions, then only
the last two are used and a new `scf.parallel` is created outside of the
herd. Returns the new `air.herd` operation.

Traits: `FunctionalStyleTransformOpTrait`, `TransformEachOpTrait`

Interfaces: `MemoryEffectsOpInterface`, `TransformOpInterface`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>first_dim</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `target` | PDL handle to an `mlir::Operation *` |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | PDL handle to an `mlir::Operation *` |


### `transform.air.par_to_launch` (transform::ParToLaunchOp)

Syntax:

```
operation ::= `transform.air.par_to_launch` $target attr-dict
```

Transform a `scf.parallel` operation into a `air.launch` operation.
Returns the new `air.launch` operation.

Traits: `FunctionalStyleTransformOpTrait`, `TransformEachOpTrait`

Interfaces: `MemoryEffectsOpInterface`, `TransformOpInterface`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>has_air_segment</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `target` | PDL handle to an `mlir::Operation *` |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | PDL handle to an `mlir::Operation *` |


### `transform.air.par_to_segment` (transform::ParToSegmentOp)

Syntax:

```
operation ::= `transform.air.par_to_segment` $target attr-dict
```

Transform a `scf.parallel` operation into a `air.segment` operation.
Returns the new `air.segment` operation.

Traits: `FunctionalStyleTransformOpTrait`, `TransformEachOpTrait`

Interfaces: `MemoryEffectsOpInterface`, `TransformOpInterface`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>has_air_segment</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `target` | PDL handle to an `mlir::Operation *` |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | PDL handle to an `mlir::Operation *` |


### `transform.air.pipeline_reduce` (transform::PipelineReduceOp)

Syntax:

```
operation ::= `transform.air.pipeline_reduce` $target attr-dict
```

Experimental

Traits: `FunctionalStyleTransformOpTrait`, `TransformEachOpTrait`

Interfaces: `MemoryEffectsOpInterface`, `TransformOpInterface`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>tile_size</code></td><td>::mlir::ArrayAttr</td><td>64-bit integer array attribute</td></tr>
<tr><td><code>pipeline_depth</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr>
<tr><td><code>direction</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>promote</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `target` | PDL handle to an `mlir::Operation *` |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | PDL handle to an `mlir::Operation *` |


### `transform.air.segment_to_aie` (transform::SegmentToAIEOp)

Syntax:

```
operation ::= `transform.air.segment_to_aie` $target attr-dict
```

Lower air.segment operations to mlir-aie modules.

Traits: `FunctionalStyleTransformOpTrait`, `TransformEachOpTrait`

Interfaces: `MemoryEffectsOpInterface`, `TransformOpInterface`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `target` | PDL handle to an `mlir::Operation *` |

#### Results:

| Result | Description |
| :----: | ----------- |
| `transformed` | PDL handle to an `mlir::Operation *` |

