# ./python/spensor/spensor/utils/spensor_global_analysis.py -*- Python -*-
#
# Copyright (C) 2025, Advanced Micro Devices, Inc.
# SPDX-License-Identifier: MIT

from dataclasses import dataclass, field
from typing import Self
from xdsl.dialects.builtin import ArrayAttr, StringAttr, IntegerAttr
from xdsl.ir import Attribute, Operation
from xdsl.dialects import arith


@dataclass
class Memory:
    """
    This class represents a general memory within a hardware architecture,
    where connections and memory space can be defined.    
    """

    name: StringAttr

    shape: ArrayAttr[IntegerAttr]
    """
    Specifies the dimensions constraints of the memory. For example, 
    L1 in NPU may be organized into 4x4 tiles [6,4] for Phoenix, 
    or 8x4 tiles [8, 4] for Strix. 
    An empty array [] indicates no constraint on shape such as external L3.
    """

    allowing_load: set[StringAttr]
    """
    A set of memory names from which data can be loaded into 
    the current memory. 
    For example, L1 can load data from L2 or L3.
    However, L3 can't load data from L1.
    """

    allowing_store: set[StringAttr]
    """
    A set of memory names to which data can be stored from
    the current memory. 
    For instance, L1 can write data to L2 and L3, 
    and similarly, L2 can't write to L1.
    """

    memory_space: Attribute | None = None
    """
    This field will be used in bufferization for generating memref types.
    For exmaple, in AIR, L3, L2 and L1 have memory_space as 0, 1, 2.
    """

    def __hash__(self) -> int:
        return (
            self.name.__hash__()
            + self.shape.__hash__()
            + hash(tuple(self.allowing_load))
            + hash(tuple(self.allowing_store))
        )


memory_mapping: dict[StringAttr, Memory] = {}
"""
Generated by Memory Analysis pass
A mapping from memory name to a Memory instance defined above
"""


loop_id: int = 0
"""
The unique identifier used exclusively within the ConstantLoop class
It's intended only to be updated by ConstantLoop
Two loop are identical if and only if they have the same id
"""


@dataclass
class ConstantLoop:
    """
    Representing a parallel loop structure with constant upper bounds. 
    It is assumed that the lower bounds are all zeros and steps are ones.
    This class is constructed through a parallel analysis pass, and it is 
    expected to be transferred to a scf.parallel operation
    Note: No operations are generated during the analysis pass; it solely 
    updates loop information within this class.
    """

    upper_bounds: tuple[int, ...]
    """
    The constant upper bounds for each dimension of the loop.
    It is assumed that the lower bounds are all zeros and steps are ones.
    """

    memory_tag: Memory | None = None
    """
    The memory tag associated with this loop indicating it's operated on 
    which memory hierarchy. 
    For example, air.herd manipulates L1 memory and it's invalid to alloc
    any L2 memory inside of a herd.
    This should correspond to a valid Memory instance identified in 
    a prior memory analysis.    
    """

    parent_loop: Self | None = None
    """
    A reference to the parent loop, if one exists.
    For instance, a parallel loop of 'herds' should be a child of a 
    parallel 'segment'.
    """

    ops: list[Operation] = field(default_factory=list[Operation])
    """
    Operations included in the current loop
    """

    loop_id: int = field(init=False)
    """
    The unique identifier for a loop structure.
    Two loop are equal iff they have the same identifier
    """

    def __post_init__(self):
        global loop_id
        self.loop_id = loop_id
        loop_id += 1

    def __hash__(self):
        return hash(self.loop_id)


op_to_parent_loop: dict[Operation, ConstantLoop] = {}
"""
One analysis result from the parallel analysis.
A mapping from an operation to its parent ConstantLoop
"""


op_to_offset_loop_vars: dict[
    Operation, tuple[tuple[int, ConstantLoop] | None, ...]
] = {}
"""
One analysis result from the parallel analysis.
For a spensor operation, this tracks how each dimension in the result uses 
induction variables from certain loops. If the i-th dimension uses the j-th 
induction variable of a loop, it is recorded; otherwise, it is None.

For example:
- split(<16x32xf32>, num_partition=4, dim=1) -> 4x<16x8xf32>
  Associated with ConstantLoop(upper_bounds = [4]).
  Mapping: split -> [None, [0, loop]] since the second dimension uses the first 
  induction variable.


- splitAll(<16x16xf32>, num_partitions=<4x8>) -> <4x8x<4x2xf32>>
  Associated with ConstantLoop(upper_bounds = [4, 8]).
  Mapping: splitAll -> [[0, loop], [1, loop]]


Sometimes the operation can use induction variables from different loops such as
scf.parallel i: 0 -> 4
  ...
  scf.parallel j: 0 -> 4
    subview buffer[i, j]
Mapping: [[0, loop1], [0, loop2]]
"""


loop_var_to_op_offsets: dict[tuple[int, ConstantLoop], list[tuple[int, Operation]]] = {}
"""
One analysis result from the parallel analysis, a reverse version of `op_to_offset_loop_vars`
By given a loop and its i-th loop induction variable, it returns all 
operations where the j-th dimension of the operation's result uses 
the variable as offsets.

For example:
- split(<16x32xf32>, num_partition=4, dim=1) -> 4x<16x8xf32>
  This split operation is associated with a constant loop(upper_bounds = [4]),
  key: [0, loop] -> value: [[1, split]] 
  Because the first induction variable in loop is used by the second dimenion of split operation


- splitAll(<16x16xf32>, num_partitions=<4x8>) -> <4x8x<4x2xf32>>
  This split operation is associated with a constant loop(upper_bounds = [4, 8])
  key: [0, loop] -> value: [[0, splitAll]]
  key: [1, loop] -> value: [[1, splitAll]]
"""


index_to_constant_op: dict[int, arith.ConstantOp] = {}
"""
A collection for holding constant operations from getConstantOpByIndex function in spensor_util.
All operation will be added to the front of a module by AppendConstant pass
"""


increase_bound_record: dict[ConstantLoop, tuple[tuple[ConstantLoop, int], ...]] = {}
"""
A record for holding changes on induction variables when performing reduce operations
It assumes that parent and child loops share the same number of induction variables.
For a given parent loop, it tracks which i-th loop variable is updated by a child loop.

For exmaple:
parallel_loop i1, j1: 0, 0 -> 4, 4
  child_loop i2, j2: 0, 0 -> 1, 1
    |
    V
parallel_loop i1, j1: 0, 0 -> 4, 1
  child_loop i2, j2: 0, 0 -> 1, 4    

In this case, second induction variable in both loops are changed
key: parent_loop -> value: [[child_loop, 1]]
"""


loop_without_subviews: set[ConstantLoop] = set()
"""
Used in MoveOpPattern in parallel analysis.
If a parallel op is created from split or splitAll op, it must contains subviews of the source
However, another possibilties is MoveOp can generate a nested parallel without subviews. (Directly movement)
In this case, they must be handled specially if there is an bound increasing. (Add extra subviews)

Examples:

- split(<16x32xf32>, num_partition=4, dim=1) -> ConstantLoop(upper_bounds= [4])
  Generated code:
  scf.parallel i: 0 -> 4
    subview buffer[i]
  Contains a subview operation, so not recorded.

- move(buff at L2, dest=L1) -> ConstantLoop(upper_bounds = [1])
  Generated code:
    scf.parallel i: 0 -> 1
      linalg.copy buff L2 to L1
  Lacks subviews, so recorded.   
"""
