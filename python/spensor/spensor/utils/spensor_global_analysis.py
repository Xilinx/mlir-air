# ./python/spensor/spensor/utils/spensor_global_analysis.py -*- Python -*-
#
# Copyright (C) 2025, Advanced Micro Devices, Inc.
# SPDX-License-Identifier: MIT

from dataclasses import dataclass, field
from typing import Self
from xdsl.dialects.builtin import ArrayAttr, StringAttr, IntegerAttr
from xdsl.ir import Attribute, Operation
from xdsl.dialects import arith


@dataclass
class Memory:
    """
    This class represents a general memory.
    """

    name: StringAttr

    shape: ArrayAttr[IntegerAttr]
    """
    For example, L1 in NPU only has 6x4 memory tiles [6,4]
    [] if has no constraints
    """

    allowing_load: set[StringAttr]
    """
    Memory names allowing loaded into the current memory
    L1 can load data from L2 or L3
    L3 can't load data from L1
    """

    allowing_store: set[StringAttr]
    """
    Memory names allowing written from the current memory
    L1 can write data to L2 and L3
    L2 can't write to L1
    """

    memory_space: Attribute | None = None
    """
    This field will be used in bufferization for generating memref types
    """

    def __hash__(self) -> int:
        return (
            self.name.__hash__()
            + self.shape.__hash__()
            + hash(tuple(self.allowing_load))
            + hash(tuple(self.allowing_store))
        )


memory_mapping: dict[StringAttr, Memory] = {}
"""
Generated by Memory Analysis pass
A mapping from memory name to its all information
"""


loop_id: int = 0
"""
The unique identifier used in ConstantLoop class
It's intended only to be updated by ConstantLoop
"""


@dataclass
class ConstantLoop:
    """
    Representing a parallel loop structure with constant bounds and steps.
    Generated by parallel analysis pass
    Notice, we don't generate any operation in the analysis pass but updating information here
    """

    upper_bounds: tuple[int, ...]
    """
    The constant upper bounds of a loop.
    We assume the lower bounds are all zeros and steps are ones
    """

    memory_tag: Memory | None = None
    """
    Memory tag associated with the loop.
    This field is expected to be a valid memory name from previous memory analysis
    """

    parent_loop: Self | None = None
    """
    Points to its parent loop.
    For example, a parallel of herds should be the son of parallel segment
    """

    ops: list[Operation] = field(default_factory=list[Operation])
    """
    Operations included in the current loop
    """

    loop_id: int = field(init=False)
    """
    The unique identifier for a loop structure.
    Two loop are equal iff they have the same identifier
    """

    def __post_init__(self):
        global loop_id
        self.loop_id = loop_id
        loop_id += 1

    def __hash__(self):
        return hash(self.loop_id)


op_to_parent_loop: dict[Operation, ConstantLoop] = {}
"""
One result from parallel analysis.
A mapping from an operation to its parent ConstantLoop
"""


op_to_offset_loop_vars: dict[
    Operation, tuple[tuple[int, ConstantLoop] | None, ...]
] = {}
"""
One result from parallel analysis.
For a spensor operation, maintaining its i-th dimension in the result uses j-th induction variable in some loop.
If i-th dimension doesn't use any variables, it's None.
"""


loop_var_to_op_offsets: dict[tuple[int, ConstantLoop], list[tuple[int, Operation]]] = {}
"""
One result from parallel analysis.
By given a loop and its i-th loop induction variable,
return all uses of the variable (j-th dimension of the operation result uses the variable as offsets)
"""


index_to_constant_op: dict[int, arith.ConstantOp] = {}
"""
A collection to holding getConstantOpByIndex function in spensor_util.
All operation will be added to the front of a module by AppendConstant pass
"""


increase_bound_record: dict[ConstantLoop, tuple[tuple[ConstantLoop, int], ...]] = {}
"""
A record for holding changes when performing reduce operations
An assumption here is parent and son loop have the same number of induction variables
So given a parent loop, it returns the i-th loop variable is updated with some son loop
"""


loop_without_subviews: set[ConstantLoop] = set()
"""
Used in MoveOpPattern in parallel analysis.
If a parallel op is created from split or splitAll op, it must contains subviews of the source
However, another possibilties is MoveOp can generate a nested parallel without subviews. (Directly movement)
In this case, they must be handled specially if there is an bound increasing. (Add extra subviews)
"""
